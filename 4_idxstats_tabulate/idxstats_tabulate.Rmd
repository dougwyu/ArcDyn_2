---
title: "idxstats_cbind"
author: "Douglas Yu"
date: "28/01/2018"
output: html_document
---

This file takes the idxstats.txt outputs of the samtools filters and combines into a single large table, which is suitable for comparing with the 


```{r}
rm(list=ls())
library(tidyverse)
# [1] "broom"       "cli"         "crayon"      "dplyr"       "dbplyr"      "forcats"     "ggplot2"     "haven"       "hms"      
# [10] "httr"        "jsonlite"    "lubridate"   "magrittr"    "modelr"      "purrr"       "readr"       "readxl"     "reprex" 
# [19] "rlang"       "rstudioapi"  "rvest"       "stringr"     "tibble"      "tidyr"       "xml2"        "tidyverse"  

# library(parallel)
# library(knitr)
# library(lattice)
# library(beeswarm)
# library(sjPlot)
# library(openxlsx)
# library(RColorBrewer)
```

```{r set paths}
# setwd("~/Dropbox/Working_docs/Roslin_Greenland/2017/bulk_samples/mapping")
folder1 <- "idxstats_files"  # this is the enclosing folder around the "BWA" folders for a given set of soups
folder2 <- "minimap2_outputs" # this is the enclosing folder for the minimap2/samtools outputs
folder3 <- "~/Dropbox/Working_docs/Roslin_Greenland/2016/bulk_samples/PlatesAB_EI_20160512/sample_tracking"  # this is the enclosing folder around the sample_tracking spreadsheet, which i will place on hpc
```


Read in all idx_stats files, add metadata to columns, and merge into one big table in long format (vertically by time)
```{r 1. read and tabulate idx files}
# produces a list of unique idx filenames (full filenames but no path)
# use this command if i have a particular folder2 value (e.g. BWA02) to pull from
# idx_files <- list.files(file.path(folder1, folder2), pattern = "*F2308_f0x2_q1_sorted.bam_idxstats\\.txt") # 

idxstatsfile <- "*F2308_f0x2_q1_sorted.bam_idxstats\\.txt"  # choose the filename suffix to match the desired samtools filter. precede with * as a wildcard. \\ is used to escape the . before txt (because it is read with grep as "any character" in list.files() below)

idx_files <- list.files(Sys.glob(file.path(folder1, "BWA??", folder2)), pattern = idxstatsfile, full.names = TRUE) 
    # Sys.glob is used to generate:  [1] "idxstats_files/BWA01" "idxstats_files/BWA02"
    # list.files is used to look in those folders for files matching "*F2308_f0x2_q1_sorted.bam_idxstats\\.txt" 
    # full.names = TRUE is used to return the pathnames
    # \\ is used to escape the . before txt (because it is read with grep as "any character")
    
# idx_files

# column names of idx files
idx_cols <- c("mitogenome", "mt_length", "mapped_reads", "unmapped_reads")

# function to read_tsv the file and filename and pathname
loadFile1 <- function(x) {
    # read in the four columns and store in df
    df <- read_tsv(x,   # previously file.path(x)
    col_names = idx_cols, na = "NA",
    col_types = cols(
        mitogenome = col_character(),
        mt_length = col_integer(),
        mapped_reads = col_integer(),
        unmapped_reads = col_integer()
        ))
    
    # read in filename, extract and sub in the first bit of the name, remove any filepaths (using basename) and store in df$sample.  example filename:  Sample_IPO3916_A1_F2308_f0x2_q60_sorted.bam_idxstats.txt

    # df$sample <- sub("([^\\.]+)\\_sorted.bam_idxstats.txt", "\\1", basename(x))
    df$sample <- sub("Sample_([A-Z,a-f,0-9]+_\\D\\d+)_[\\w]+_sorted.bam_idxstats.txt", "\\1", basename(x), perl=TRUE)
    # \\w any letter, digit, underscore
    # \\D any non-digit, \\d any digit

    df$well <- sub("Sample_[A-Z,a-f,0-9]+_(\\D\\d+)_[\\w]+_sorted.bam_idxstats.txt", "\\1", basename(x), perl=TRUE)
    # extract well number from filename
    # \\w any letter, digit, underscore

    df$samtools_filter <- sub("Sample_[\\w]+_(F[\\w]+)_sorted.bam_idxstats.txt", "\\1", basename(x), perl=TRUE)
    # extract samtools parameters from filename
    
    df$pathname <- x
    # store full pathname in df$pathname
    
    # output is df
    df 
    }

# lapply the loadFile() function to all of the idx_files, save the output in idx as a list
idx <- purrr::map(idx_files, loadFile1) # map is equivalent to lapply

# Code from:  Location 6472 in Buffalo, Vince. Bioinformatics Data Skills: Reproducible and Robust Research with Open Source Tools (Kindle Location 6493). O'Reilly Media. Kindle Edition. 

# combine lists into a single dataframe (using do.call(rbind, idx)), reorder columns, delete unmapped_reads column, and remove rows that have "*" in the mitogenome field (the last line of each idxstats table)
idx <- do.call(rbind, idx) %>% dplyr::select(mitogenome, mt_length, mapped_reads, sample, well, samtools_filter, pathname) %>% dplyr::filter(mitogenome != "*")

# str(idx)
# dim(idx)
# sanity checks
idx %>% distinct(well) %>% count()  # number of distinct values of well, as a sanity check
idx %>% distinct(sample) %>% count()  # number of distinct values of sample:  176.  I originally input 192, but only have 176 idx files.  
idx %>% distinct(pathname) %>% count()  # number of distinct values of sample:  176.  I originally input 192, but only have 176 idx files.  

idx_mitogenome_table <- idx %>% group_by(well) %>% distinct(mitogenome) %>% count()

# 28160/160 = 176 # 28160 rows / 160 mitogenomes = 176 samples.  

```


Merge with sample excel workbook to add the sample date information

```{r 2. add sample metadata}
filename <- "Samples_for_sequencing_at_TGAC_Zackenberg_bulk_samples_April_2016_20160512.xlsx"

samplemetadata <- read_excel(file.path(folder3, filename), sheet = "original", na = "NA") 

idx_meta <- left_join(idx, samplemetadata) # R message:  "Joining, by = c("sample", "well")"

temp <- str_split(idx_meta$Full_name_of_the_sample, "_", simplify = TRUE) 
colnames(temp) <- c("Date", "Plot", "Trap", "Week", "Empty")
temp <- as.data.frame(temp) %>% dplyr::select(Date:Week) 
temp$Date <- as_date(ymd(temp$Date))
idx_meta <- cbind(temp, idx_meta)
rm(temp)

names(idx_meta)
#  [1] "Date"                    "Plot"                    "Trap"                    "Week"                   
#  [5] "mitogenome"              "mt_length"               "mapped_reads"            "sample"                 
#  [9] "well"                    "samtools_filter"         "pathname"                "Full_name_of_the_sample"
# [13] "Sample_alias"            "ArcDyn_Plate_name"       "EI_Plate_name"           "row"                    
# [17] "column"                  "TGAC_barcode"            "sample_reference"        "species_name"           
# [21] "barcode_used"            "Sample_type"             "Concentration_ng_per_ul" "Sample_volume_ul"       
# [25] "Quantification_method"   "x.260_280_ratio"         "x.260_230_ratio"         "Buffer_used"            
# [29] "Extraction_kit_protocol"

idx_meta <- idx_meta %>% dplyr::select(-row, -column, -sample_reference, -species_name, -barcode_used, -Sample_type, -x.260_230_ratio, -Buffer_used, -Extraction_kit_protocol) %>% dplyr::arrange(Date, Trap)

names(idx_meta)
#  [1] "Date"                    "Plot"                    "Trap"                    "Week"                   
#  [5] "mitogenome"              "mt_length"               "mapped_reads"            "sample"                 
#  [9] "well"                    "samtools_filter"         "pathname"                "Full_name_of_the_sample"
# [13] "Sample_alias"            "ArcDyn_Plate_name"       "EI_Plate_name"           "TGAC_barcode"           
# [17] "Concentration_ng_per_ul" "Sample_volume_ul"        "Quantification_method"   "x.260_280_ratio"  
```


```{r sanity checks}
idx_meta %>% distinct(Date) %>% count()  # number of distinct values of Date:  68
idx_meta %>% distinct(Plot) %>% count()  # number of distinct values of Plot:  should be 1
idx_meta %>% distinct(Trap) %>% count()  # number of distinct values of Trap:  should be 3 (A,B,C)
idx_meta %>% distinct(Week) %>% count()  # number of distinct values of Week:  18
idx_meta %>% distinct(mitogenome) %>% count()  # number of distinct values of mitogenome (incl 3 COI spikes):  160
idx_meta %>% distinct(sample) %>% count()  # number of distinct values of sample:   176 (176 is the number of input idx files)
idx_meta %>% distinct(sample)
idx_meta %>% distinct(Sample_alias) %>% count()  # number of distinct values of Sample_alias:  should be = sample = 176
idx_meta %>% distinct(Sample_alias)
idx_meta %>% distinct(well) %>% count()  # number of distinct values of well:  96
idx_meta %>% distinct(ArcDyn_Plate_name) %>% count()  # number of distinct values of ArcDyn_Plate_name:  should be 2
idx_meta %>% distinct(samtools_filter) %>% count()  # number of distinct values of samtools_filter: should be 1

```


```{r read in genomecov_d.txt.gz files and add to idx_meta}
# setwd("~/Dropbox/Working_docs/Roslin_Greenland/2017/bulk_samples/mapping")

genomecovfile <- "*sorted_genomecov_d\\.txt\\.gz"  # choose the filename suffix to match the desired samtools filter. precede with * as a wildcard. \\ is used to escape the . before txt (because it is read with grep as "any character" in list.files() below)

genomecov_files <- list.files(Sys.glob(file.path(folder1, "BWA??", folder2)), pattern = genomecovfile, full.names = TRUE) 
    # Sys.glob is used to generate:  [1] "idxstats_files/BWA01" "idxstats_files/BWA02"
    # list.files is used to look in those folders for files matching "*F2308_f0x2_q1_sorted.bam_idxstats\\.txt" 
    # full.names = TRUE is used to return the pathnames
    # \\ is used to escape the . before txt (because it is read with grep as "any character")
    
# genomecov_files

# column names of genomecov_files
columnnames <- c("mitogenome", "position", "coverage")

# function to read_tsv the file
loadFile2 <- function(x) {
    df <- read_tsv(gzfile(x),   # e.g. "BWA02/minimap2_outputs/Sample_IPO3916_A1_F2308_f0x2_q1_sorted_genomecov_d.txt.gz" 
    col_names = columnnames, na = "NA",
    col_types = cols(
        mitogenome = col_character(),
        position = col_integer(),
        coverage = col_integer()),
    trim_ws = TRUE
    )
    
    # read in filename, extract and sub in the first bit of the name, remove any filepaths (using basename) and store in df$sample.  example filename:  Sample_IPO3916_A1_F2308_f0x2_q1_sorted_genomecov_d.txt.gz

    # df$sample <- sub("([^\\.]+)\\_sorted.bam_idxstats.txt", "\\1", basename(x))
    df$sample <- sub("Sample_([A-Z,a-f,0-9]+_\\D\\d+)_[\\w]+_sorted_genomecov_d.txt.gz", "\\1", basename(x), perl=TRUE)
    # \\w any letter, digit, underscore
    # \\D any non-digit, \\d any digit

    df$well <- sub("Sample_[A-Z,a-f,0-9]+_(\\D\\d+)_[\\w]+_sorted_genomecov_d.txt.gz", "\\1", basename(x), perl=TRUE)
    # extract well number from filename
    # \\w any letter, digit, underscore

    df$samtools_filter <- sub("Sample_[\\w]+_(F[\\w]+)_sorted_genomecov_d.txt.gz", "\\1", basename(x), perl=TRUE)
    # extract samtools parameters from filename
    
    df$pathname_genomecov <- x
    # store full pathname in df$pathname
    
    df <- df %>% dplyr::group_by(mitogenome) %>% summarise(sum_coverage = sum(coverage), mean_coverage = mean(coverage), stddev = sd(coverage), coefvar = sd(coverage)/mean(coverage), length = n(), sample = first(sample), well = first(well), samtools_filter = first(samtools_filter), pathname_genomecov = first(pathname_genomecov)) 
    
    # output is df
    df 
}


# lapply the loadFile3() function to all of the genomecov_files, save the output in genomecovfiles as a list
genomecoverages_summ <- purrr::map(genomecov_files, loadFile2) # map is equivalent to lapply
# try mclapply

# rbind the list into a dataframe
genomecoverages_summ <- do.call(rbind, genomecoverages_summ)

# left_join genomecoverages_summ to idx_meta
idx_meta_genomecov <- left_join(idx_meta, genomecoverages_summ) 

idx_meta_genomecov <- idx_meta_genomecov %>% arrange(Date, Trap)

names(idx_meta_genomecov)
```


```{r cleanup files}
rm(genomecoverages_summ)
rm(idx)
rm(idx_meta)
rm(samplemetadata)
```


```{r tidyr make wide table}
# create variable from Date and Trap(ABC)
# stringr::str_pad(x, width = 2, side = "left", pad = "0")  # to ensure that the date always has two digits, e.g. 07.
idx_meta_genomecov$DateTrap <- str_c("Date", year(idx_meta_genomecov$Date), str_pad(month(idx_meta_genomecov$Date), 2, side = "left", pad = "0"), str_pad(day(idx_meta_genomecov$Date), 2, side = "left", pad = "0"), idx_meta_genomecov$Trap, sep = "_")

# use grepl() to find mitogenome names that are COI spike names
idx_meta_genomecov$COI_spike <- if_else(grepl("ng_COI", idx_meta_genomecov$mitogenome), "COI_Spike", "ArcDyn_Species")
    
idx_meta_genomecov <- idx_meta_genomecov %>% dplyr::arrange(DateTrap, COI_spike) # sort to put COI-spike mitogenomes at end of every DateTrap

# these tables check that i only have one row for each Full_name_of_the_sample, DateTrap, and pathname
idxstats_by_Full_name_of_the_sample <- idx_meta_genomecov %>% dplyr::group_by(Full_name_of_the_sample) %>% dplyr::distinct(pathname) %>% dplyr::count() %>% dplyr::arrange(desc(n))  

idxstats_by_DateTrap <- idx_meta_genomecov %>% dplyr::group_by(DateTrap) %>% dplyr::distinct(pathname) %>% dplyr::count() %>% dplyr::arrange(desc(n))  

idxstats_by_pathname <- idx_meta_genomecov %>% dplyr::group_by(pathname) %>% dplyr::distinct(pathname) %>% dplyr::count() %>% dplyr::arrange(desc(n)) 
# i originally found that TrapC_2013_Jul_22 occurred once for week 30 and once for week 29.  I checked the original Excel worksheet and found that 2013JUL22_Art3_TrapC_Wk29 should be 2013JUL15_Art3_TrapC_Wk29.  Thus, the TrapC_2013_Jul_22/week29 combination shouldn't exist.  I have fixed the Excel file.

# Make wide table for visualisation (left to right should follow temporal order (DateTrap))
idx_meta_genomcov_wide <- idx_meta_genomecov %>% dplyr::select(DateTrap, mitogenome, mapped_reads) %>% dplyr::arrange(DateTrap) %>% tidyr::spread(DateTrap, mapped_reads) %>% dplyr::arrange(mitogenome)

# sorts wide table by whether the mitogenome name contains "ng_COI".  If TRUE, then naturally sorts to the end (because F from FALSE comes before T from TRUE)
idx_meta_genomcov_wide <- idx_meta_genomcov_wide %>% dplyr::arrange(grepl("ng_COI", idx_meta_genomcov_wide$mitogenome))


```



## Next steps:

1. DONE Read in all idx_stats files, add sample metadata to columns, and merge into one table in long format (vertically by time)
2. DONE merge with sample excel workbook to add the sample date information
3. DONE go through the genomecov files and calculate the mean and standard deviation of coverage for each mitogenome/sample and add the columns to the idx table
4. DONE make wide table using tidyr (the column data format should be DateTrap (e.g. 1998_08_05_TrapA) in temporal order).  

5. DONE platesGH:  combine_fastq, fastQC, multiqc (using PKG-ENQ-2379-Data_Transfer-PSEQ-1586-trimmed), remove orig fastq.gz files.  
6. DONE platesA2B2: combine_fastq, fastQC, multiqc, remove orig fastq.gz files
7. minimap2/samtools for platesGH
8. minimap2/samtools for platesA2B2

9. adapt R code for running on hpc and run, COMPARE WITH YINQIU'S BWA CODE, THE POSITIVE CONTROLS, THE COI SPIKE RATIOS, THE SEASONAL PATTERNS

10. make textfile for taxonomy (class, order, family, genus, species) of each mitogenome and join to idx_meta_genomecov

11. visualise minimap2 bam files and check that i am not mapping to the Ns between the protein-coding genes. SHOULD I SUBTRACT A FIXED NUMBER FROM EACH MITOGENOME LENGTH TO CALCULATE THE CORRECT LENGTH OF THE CODING PORTION?  



10. DONE confirm that i have the correct number of samples (compare with number of input files) e.g. PlatesAB only have 176 bam files (or did i only download 176 bam files?) but of course we created 2*96=192 files, some of which failed to sequence
11. DONE Debug the bug that causes sample to have repeated lines, using a tabulate command to check that I don't have repeated lines.  Answer: re-run the minimap2/samtools/bedtools scripts and redownload the idxstats files.  i put the same idxstats files into multiple BWA folders in my test folders


## names(idx_meta_genomcov)
 [1] "Date"                    "Plot"                    "Trap"                    "Week"                   
 [5] "mitogenome"              "mt_length"               "mapped_reads"            "sample"                 
 [9] "well"                    "samtools_filter"         "pathname"                "Full_name_of_the_sample"
[13] "Sample_alias"            "ArcDyn_Plate_name"       "EI_Plate_name"           "TGAC_barcode"           
[17] "Concentration_ng_per_ul" "Sample_volume_ul"        "Quantification_method"   "x.260_280_ratio"        
[21] "sum_coverage"            "mean_coverage"           "stddev"                  "coefvar"                
[25] "length"                  "pathname_genomecov"  

Metadata:
From idxstats.txt
Date:  Date of ArcDyn Sample
Plot:  Zackenberg Plot (only Art3)
Trap:  Window trap within Art3 (A, B, C)
Week:  Week of the year (alternative to Date)
mitogenome:  name of mitogenome sequencer (from reference fasta file used by minimap2)
mt_length:  length of the mitogenome (including Ns between the genes) used by minimap2
mapped_reads:  number of reads mapped to each mitogenome by minimap2 and filtered through samtools
sample:  unique sample name derived from each sample's foldername (e.g. Sample_IPO3916_A1 -> IPO3916_A1). IPO3916 refers to the Plate and A1 refers to the well. I use this to link to my ArcDyn sample metadata
well:  well of the Plate
samtools_filter:  parameter used by samtools view to filter out badly mapped reads (e.g. -F2308 -f0x2 -q1 -> F2308_f0x2_q1)
pathname:  path to the idx_stats file

From Excel spreadsheet that ArcDyn uses to record metadata for each sample
Full_name_of_the_sample:  full name of the sample from the ArcDyn metadata (e.g. 1999JUL08_Art3_TrapA_Wk27). 
Sample_alias:  code for the Year_Trap_Week (e.g. 98_B_33)
ArcDyn_Plate_name:  ArcDyn plate name (e.g. Anteater, which is Plate A)
EI_Plate_name:  name of plate given by Earlham Institute (e.g. IPO3916)
TGAC_Barcode:  number on the barcode sticker that i placed on the plate (SAM27529_PRO 1323_S1_gDNA).  this links back to the photo i take of each plate after it is loaded.
Concentration_ng_per_ul:  DNA concentration as it is given to EI
Sample_volume_ul:  how much volume of liquid given to EI per sample in each well
Quantification method: the method ArcDyn used to quantify DNA amount
x.260_280_ratio:  the 260/280 ratio ArcDyn measured for the sample's DNA

From bedtools/genomecov -d output file
sum_coverage:  sum of the coverage per nucleotide = the total bases of all the reads that mapped to each mitogenome
mean_coverage:  sum/length of the mitogenome that was mapped to
stddev:  standard deviation of the coverage (e.g. is the mapping even or uneven?)
coefvar:  stddev/mean_coverage.  another measure of unevenness
length:  length of the mitogenome being mapped to.  should be the same as mt_length
pathname_genomecov:  path to the bedtools genomecov -d output file





